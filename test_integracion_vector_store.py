#!/usr/bin/env python3
"""
Test de integraci√≥n para VectorStoreService Real - VERSI√ìN FINAL COMPLETA
Incluye c√°lculo autom√°tico de embeddings
TFM Vicente Caruncho - Sistemas Inteligentes
"""

import sys
import os
import time
from pathlib import Path
from datetime import datetime

# A√±adir el directorio ra√≠z al path
project_root = Path(__file__).parent
sys.path.insert(0, str(project_root))


def test_vector_store_service_integration():
    """Test completo de integraci√≥n del VectorStoreService real con embeddings"""
    print("üß™ TEST INTEGRACI√ìN VECTORSTORESERVICE REAL - VERSI√ìN FINAL")
    print("=" * 70)
    
    try:
        print("üì¶ 1. Importando implementaci√≥n real desde el proyecto...")
        
        # Importar desde la ubicaci√≥n real del proyecto
        from app.services.vector_store_service import (
            VectorStoreService,
            get_vector_store_service,
            is_vector_store_available,
            VectorStoreType
        )
        from app.models import DocumentChunk
        
        print("   ‚úÖ Implementaci√≥n real importada correctamente desde app.services")
        
    except ImportError as e:
        print(f"   ‚ùå Error importando: {e}")
        print("   üí° Aseg√∫rate de que app/services/vector_store_service.py tiene la implementaci√≥n real")
        return False
    except Exception as e:
        print(f"   ‚ùå Error inesperado: {e}")
        return False
    
    try:
        print("\nüîß 2. Verificando que ya no es modo mock...")
        
        # Usar la instancia global (la que usar√° tu aplicaci√≥n)
        global_service = get_vector_store_service()
        global_available = is_vector_store_available()
        
        print(f"   Store activo: {global_service.get_active_store_type()}")
        print(f"   FAISS disponible: {global_service.faiss_available}")
        print(f"   ChromaDB disponible: {global_service.chromadb_available}")
        print(f"   M√©todo is_available(): {global_service.is_available()}")
        
        # Verificar que no es mock
        if hasattr(global_service, 'active_store') and global_service.active_store is not None:
            print("   ‚úÖ √âXITO: Ya no es modo mock, tiene store real")
        else:
            print("   ‚ùå ADVERTENCIA: Parece que sigue en modo mock o sin stores")
            return False
        
        if not global_available:
            print("   ‚ùå La instancia global no est√° disponible")
            return False
        
        print("   ‚úÖ VectorStoreService real inicializado correctamente")
        
        # Usar la instancia global para todos los tests
        service = global_service
        
    except Exception as e:
        print(f"   ‚ùå Error verificando servicio: {e}")
        print(f"   Detalles del error: {type(e).__name__}: {str(e)}")
        return False
    
    try:
        print("\nüìÑ 3. Creando documentos de prueba...")
        
        # Crear documentos de prueba con la estructura CORRECTA de tu proyecto
        original_test_docs = [
            DocumentChunk(
                id="test_doc_1",
                content="El Ayuntamiento de Valencia gestiona los servicios municipales para ciudadanos",
                metadata={
                    "source": "web",
                    "tipo": "informaci√≥n_municipal",
                    "ciudad": "Valencia",
                    "categoria": "servicios_publicos"
                },
                source_file="test_web_source.html",
                chunk_index=0
            ),
            DocumentChunk(
                id="test_doc_2",
                content="Los ciudadanos pueden solicitar certificados digitales a trav√©s de la sede electr√≥nica",
                metadata={
                    "source": "pdf",
                    "tipo": "tramites_digitales",
                    "servicio": "certificados",
                    "modalidad": "online"
                },
                source_file="certificados_digitales.pdf",
                chunk_index=1
            ),
            DocumentChunk(
                id="test_doc_3",
                content="La administraci√≥n electr√≥nica facilita los procesos burocr√°ticos mediante tecnolog√≠a",
                metadata={
                    "source": "documento",
                    "tipo": "modernizaci√≥n",
                    "ambito": "administraci√≥n",
                    "tecnologia": "rag"
                },
                source_file="modernizacion_admin.docx",
                chunk_index=2
            ),
            DocumentChunk(
                id="test_doc_4",
                content="El padr√≥n municipal registra todos los vecinos del municipio para gesti√≥n censal",
                metadata={
                    "source": "base_datos",
                    "tipo": "registro_civil",
                    "ambito": "censo",
                    "categoria": "padron"
                },
                source_file="padron_municipal.db",
                chunk_index=3
            )
        ]
        
        print(f"   ‚úÖ Creados {len(original_test_docs)} documentos de prueba")
        
    except Exception as e:
        print(f"   ‚ùå Error creando documentos: {e}")
        return False
    
    try:
        print("\nüß† 4. Calculando embeddings para los documentos...")
        
        # Importar y verificar EmbeddingService
        from app.services.rag.embeddings import embedding_service
        
        if not embedding_service.is_available():
            print("   ‚ùå EmbeddingService no disponible")
            print("   üí° Ejecuta primero: python test_embedding_service.py")
            return False
        
        print(f"   üìä Calculando embeddings para {len(original_test_docs)} documentos...")
        
        # Calcular embeddings para cada documento
        documents_with_embeddings = []
        embedding_times = []
        
        for i, doc in enumerate(original_test_docs, 1):
            print(f"   üîÑ Procesando documento {i}/{len(original_test_docs)}: {doc.id}")
            
            start_time = time.time()
            
            # Calcular embedding para el contenido
            embedding = embedding_service.encode_single_text(doc.content)
            embedding_time = (time.time() - start_time) * 1000
            embedding_times.append(embedding_time)
            
            # Verificar que el embedding es v√°lido
            if embedding is None or len(embedding) == 0:
                print(f"   ‚ùå Error: embedding inv√°lido para {doc.id}")
                return False
            
            # Crear nuevo chunk con embedding incluido
            doc_with_embedding = DocumentChunk(
                id=doc.id,
                content=doc.content,
                metadata=doc.metadata.copy(),
                source_file=doc.source_file,
                chunk_index=doc.chunk_index,
                embedding=embedding.tolist() if hasattr(embedding, 'tolist') else list(embedding)
            )
            
            documents_with_embeddings.append(doc_with_embedding)
            
            print(f"      ‚úÖ Embedding calculado en {embedding_time:.2f}ms (dim: {len(embedding)})")
        
        avg_embedding_time = sum(embedding_times) / len(embedding_times)
        total_embedding_time = sum(embedding_times)
        
        print(f"   üìä Resumen embeddings:")
        print(f"   - Tiempo total: {total_embedding_time:.1f}ms")
        print(f"   - Tiempo promedio: {avg_embedding_time:.2f}ms por documento")
        print(f"   - Dimensi√≥n: {len(documents_with_embeddings[0].embedding)}")
        print(f"   - Modelo: all-MiniLM-L6-v2")
        
        print("   ‚úÖ Todos los embeddings calculados correctamente")
        
    except Exception as e:
        print(f"   ‚ùå Error calculando embeddings: {e}")
        print(f"   Tipo de error: {type(e).__name__}")
        return False
    
    try:
        print("\nüíæ 5. Agregando documentos con embeddings al vector store...")
        
        # Agregar documentos con metadatos de fuente
        source_metadata = {
            "batch_id": "test_batch_final",
            "timestamp": datetime.now().isoformat(),
            "test_run": True,
            "origen": "test_vector_store_service_final",
            "version": "v3.0_con_embeddings",
            "embedding_model": "all-MiniLM-L6-v2",
            "embedding_dimension": len(documents_with_embeddings[0].embedding)
        }
        
        print(f"   üéØ Store activo: {service.get_active_store_type()}")
        print(f"   üìä Documentos a agregar: {len(documents_with_embeddings)}")
        
        start_time = time.time()
        success = service.add_documents(documents_with_embeddings, source_metadata)
        add_time = (time.time() - start_time) * 1000
        
        if success:
            print(f"   ‚úÖ {len(documents_with_embeddings)} documentos agregados en {add_time:.2f}ms")
            print(f"   ‚úÖ Store utilizado: {service.get_active_store_type()}")
            print(f"   ‚úÖ Con embeddings pre-calculados ‚úì")
            
            # Actualizar variable para siguientes tests
            test_docs = documents_with_embeddings
        else:
            print("   ‚ùå Error agregando documentos al store")
            print("   üí° Revisa los logs arriba para m√°s detalles")
            return False
            
    except Exception as e:
        print(f"   ‚ùå Error en operaci√≥n add_documents: {e}")
        print(f"   Tipo de error: {type(e).__name__}")
        return False
    
    try:
        print("\nüîç 6. Ejecutando b√∫squedas sem√°nticas...")
        
        # Lista de queries de prueba espec√≠ficas para administraci√≥n local
        test_queries = [
            "servicios municipales Valencia ciudadanos",
            "certificados digitales sede electr√≥nica", 
            "administraci√≥n electr√≥nica procesos burocr√°ticos",
            "padr√≥n municipal vecinos censo",
            "tramites online ayuntamiento",
            "modernizaci√≥n tecnolog√≠a administraci√≥n"
        ]
        
        search_results = []
        total_search_time = 0
        
        for i, query in enumerate(test_queries, 1):
            print(f"\n   üîç B√∫squeda {i}/{len(test_queries)}: '{query}'")
            
            start_time = time.time()
            results = service.search(query, k=3)
            search_time = (time.time() - start_time) * 1000
            total_search_time += search_time
            
            print(f"      ‚è±Ô∏è Tiempo: {search_time:.2f}ms")
            print(f"      üìä Resultados: {len(results)}")
            
            # Verificar y mostrar resultados
            if results and isinstance(results, list) and len(results) > 0:
                first_result = results[0]
                if isinstance(first_result, dict):
                    # Mostrar informaci√≥n del mejor resultado
                    content = first_result.get('content', 'Sin contenido')
                    score = first_result.get('score', 'Sin score')
                    metadata = first_result.get('metadata', {})
                    
                    preview = content[:50] + "..." if len(content) > 50 else content
                    print(f"      ü•á Mejor resultado: {preview}")
                    
                    if score != 'Sin score' and score is not None:
                        print(f"      üìà Relevancia: {score:.4f}")
                    
                    if metadata:
                        tipo = metadata.get('tipo', 'N/A')
                        source = metadata.get('source', 'N/A')
                        print(f"      üè∑Ô∏è Tipo: {tipo} | Fuente: {source}")
                
                search_results.append({
                    'query': query,
                    'time_ms': search_time,
                    'results_count': len(results),
                    'success': True,
                    'relevance_score': first_result.get('score') if results else None
                })
            else:
                print("      ‚ö†Ô∏è Sin resultados relevantes encontrados")
                search_results.append({
                    'query': query,
                    'time_ms': search_time,
                    'results_count': 0,
                    'success': False,
                    'relevance_score': None
                })
        
        # Calcular estad√≠sticas finales
        successful_searches = sum(1 for r in search_results if r['success'])
        avg_search_time = total_search_time / len(test_queries)
        
        print(f"\n   üìä Resumen de b√∫squedas:")
        print(f"   ‚úÖ Exitosas: {successful_searches}/{len(test_queries)}")
        print(f"   ‚è±Ô∏è Tiempo total: {total_search_time:.1f}ms")
        print(f"   ‚öñÔ∏è Tiempo promedio: {avg_search_time:.2f}ms por b√∫squeda")
        print(f"   üéØ Store usado: {service.get_active_store_type()}")
        print(f"   üß† B√∫squeda sem√°ntica: ‚úì Funcionando")
        
        if successful_searches == 0:
            print("   ‚ùå No se obtuvieron resultados en ninguna b√∫squeda")
            return False
        elif successful_searches < len(test_queries):
            print(f"   ‚ö†Ô∏è {len(test_queries) - successful_searches} b√∫squedas sin resultados")
        
        print("   ‚úÖ B√∫squedas sem√°nticas funcionando correctamente")
        
    except Exception as e:
        print(f"   ‚ùå Error en b√∫squedas: {e}")
        return False
    
    try:
        print("\nüìä 7. Verificando estad√≠sticas del sistema...")
        
        stats = service.get_stats()
        
        print("   üìà Estado del sistema:")
        print(f"   - Store activo: {stats.get('active_store')}")
        print(f"   - Store preferido: {stats.get('preferred_store')}")
        print(f"   - Fallback habilitado: {stats.get('fallback_enabled')}")
        print(f"   - Stores disponibles: {stats.get('total_stores_available')}")
        
        stores_available = stats.get('stores_available', {})
        for store_name, available in stores_available.items():
            status = "‚úÖ" if available else "‚ùå"
            print(f"   - {store_name}: {status}")
        
        # Estad√≠sticas del store activo
        if 'active_store_stats' in stats:
            active_stats = stats['active_store_stats']
            print("   üìä M√©tricas del store activo:")
            
            for key, value in active_stats.items():
                if key == 'total_vectors':
                    print(f"   - Vectores indexados: {value}")
                elif key == 'total_documents': 
                    print(f"   - Documentos almacenados: {value}")
                elif key == 'memory_usage_mb':
                    print(f"   - Memoria utilizada: {value:.1f} MB")
                elif key == 'disk_usage_mb':
                    print(f"   - Espacio en disco: {value:.1f} MB")
                elif key == 'avg_search_time':
                    print(f"   - Tiempo b√∫squeda promedio: {value:.2f}ms")
        
        print("   ‚úÖ Estad√≠sticas del sistema obtenidas correctamente")
        
    except Exception as e:
        print(f"   ‚ùå Error obteniendo estad√≠sticas: {e}")
        return False
    
    try:
        print("\nüè• 8. Ejecutando health check completo...")
        
        health = service.get_health_status()
        
        overall_status = health.get('overall_status', 'unknown')
        timestamp = health.get('timestamp', 'N/A')
        
        print(f"   üè• Estado general: {overall_status.upper()}")
        print(f"   ‚è∞ Verificado en: {timestamp}")
        
        services_health = health.get('services', {})
        print(f"   üîß Servicios monitoreados: {len(services_health)}")
        
        all_healthy = True
        
        for service_name, service_health in services_health.items():
            status = service_health.get('status', 'unknown')
            available = service_health.get('available', False)
            error = service_health.get('error')
            
            if status == "healthy":
                status_icon = "‚úÖ"
            elif status == "error":
                status_icon = "‚ùå"
                all_healthy = False
            else:
                status_icon = "‚ö†Ô∏è"
                all_healthy = False
            
            print(f"   {status_icon} {service_name.capitalize()}: {status}")
            
            if error:
                print(f"      ‚ö†Ô∏è Error: {error}")
            
            # Mostrar m√©tricas espec√≠ficas si est√°n disponibles
            if 'total_vectors' in service_health:
                print(f"      üìä Vectores: {service_health['total_vectors']}")
            if 'total_documents' in service_health:
                print(f"      üìä Documentos: {service_health['total_documents']}")
            if 'memory_usage_mb' in service_health:
                print(f"      üíæ Memoria: {service_health['memory_usage_mb']:.1f} MB")
        
        if all_healthy:
            print("   ‚úÖ Todos los servicios est√°n saludables")
        else:
            print("   ‚ö†Ô∏è Algunos servicios tienen problemas")
        
        print("   ‚úÖ Health check completado exitosamente")
        
    except Exception as e:
        print(f"   ‚ùå Error en health check: {e}")
        return False
    
    try:
        print("\n‚öîÔ∏è 9. Comparando rendimiento entre stores...")
        
        if service.faiss_available and service.chromadb_available:
            print("   üî• Ambos stores disponibles - ejecutando comparaci√≥n de rendimiento")
            
            comparison_query = "administraci√≥n municipal servicios ciudadanos digitales"
            comparison = service.compare_stores(comparison_query)
            
            print(f"   üîç Query de benchmark: '{comparison_query}'")
            print(f"   ‚è∞ Ejecutado: {comparison.get('timestamp')}")
            
            results = comparison.get('comparison_results', {})
            
            faiss_success = False
            chromadb_success = False
            faiss_time = 0
            chromadb_time = 0
            
            for store_name, store_results in results.items():
                print(f"\n   üìã Resultados {store_name.upper()}:")
                
                if store_results.get('status') == 'success':
                    time_ms = store_results.get('search_time_ms', 0)
                    count = store_results.get('results_count', 0)
                    print(f"      ‚è±Ô∏è Tiempo de b√∫squeda: {time_ms:.3f}ms")
                    print(f"      üìä Resultados encontrados: {count}")
                    print(f"      ‚úÖ Estado: Exitoso")
                    
                    if store_name == 'faiss':
                        faiss_success = True
                        faiss_time = time_ms
                    elif store_name == 'chromadb':
                        chromadb_success = True
                        chromadb_time = time_ms
                        
                else:
                    error = store_results.get('error', 'Error desconocido')
                    print(f"      ‚ùå Error: {error}")
            
            # An√°lisis comparativo
            if faiss_success and chromadb_success:
                print(f"\n   üèÜ AN√ÅLISIS COMPARATIVO:")
                if faiss_time < chromadb_time:
                    speedup = chromadb_time / faiss_time if faiss_time > 0 else 0
                    print(f"   ü•á FAISS es {speedup:.1f}x m√°s r√°pido que ChromaDB")
                    print(f"      FAISS: {faiss_time:.3f}ms vs ChromaDB: {chromadb_time:.3f}ms")
                elif chromadb_time < faiss_time:
                    speedup = faiss_time / chromadb_time if chromadb_time > 0 else 0
                    print(f"   ü•á ChromaDB es {speedup:.1f}x m√°s r√°pido que FAISS")
                    print(f"      ChromaDB: {chromadb_time:.3f}ms vs FAISS: {faiss_time:.3f}ms")
                else:
                    print(f"   ü§ù Rendimiento similar entre ambos stores")
                    
            print("   ‚úÖ Comparaci√≥n de rendimiento completada")
        else:
            available_stores = []
            if service.faiss_available:
                available_stores.append("FAISS")
            if service.chromadb_available:
                available_stores.append("ChromaDB")
            
            print(f"   ‚ÑπÔ∏è Solo {', '.join(available_stores)} disponible(s)")
            print("   ‚è≠Ô∏è Comparaci√≥n omitida (se necesitan ambos stores para comparar)")
        
    except Exception as e:
        print(f"   ‚ùå Error en comparaci√≥n: {e}")
        return False
    
    try:
        print("\nüîÑ 10. Probando cambio din√°mico entre stores...")
        
        current_store = service.get_active_store_type()
        print(f"   üìç Store actual: {current_store.upper()}")
        
        # Intentar cambiar a store alternativo
        if current_store == "faiss" and service.chromadb_available:
            print("   üîÑ Intentando cambio: FAISS ‚Üí ChromaDB")
            success = service.switch_store("chromadb")
            
            if success:
                new_store = service.get_active_store_type()
                print(f"   ‚úÖ Cambio exitoso: {current_store} ‚Üí {new_store}")
                
                # Probar b√∫squeda r√°pida con nuevo store
                quick_results = service.search("test cambio de store", k=2)
                print(f"   üîç Test b√∫squeda con {new_store}: {len(quick_results)} resultados")
                
                # Volver al store original
                restore_success = service.switch_store("faiss")
                restored_store = service.get_active_store_type()
                
                if restore_success:
                    print(f"   üîô Store restaurado: {new_store} ‚Üí {restored_store}")
                else:
                    print("   ‚ö†Ô∏è Error restaurando store original")
            else:
                print("   ‚ùå Fallo al cambiar a ChromaDB")
                
        elif current_store == "chromadb" and service.faiss_available:
            print("   üîÑ Intentando cambio: ChromaDB ‚Üí FAISS")
            success = service.switch_store("faiss")
            
            if success:
                new_store = service.get_active_store_type()
                print(f"   ‚úÖ Cambio exitoso: {current_store} ‚Üí {new_store}")
                
                # Probar b√∫squeda r√°pida con nuevo store
                quick_results = service.search("test cambio de store", k=2)
                print(f"   üîç Test b√∫squeda con {new_store}: {len(quick_results)} resultados")
                
                # Volver al store original
                restore_success = service.switch_store("chromadb")
                restored_store = service.get_active_store_type()
                
                if restore_success:
                    print(f"   üîô Store restaurado: {new_store} ‚Üí {restored_store}")
                else:
                    print("   ‚ö†Ô∏è Error restaurando store original")
            else:
                print("   ‚ùå Fallo al cambiar a FAISS")
        else:
            print("   ‚ÑπÔ∏è Solo un store disponible - cambio din√°mico omitido")
        
        print("   ‚úÖ Test de cambio din√°mico completado")
        
    except Exception as e:
        print(f"   ‚ùå Error probando cambio de store: {e}")
        return False
    
    # RESULTADO FINAL EXITOSO
    print("\n" + "="*70)
    print("üéâ RESULTADO FINAL - ¬°√âXITO COMPLETO!")
    print("="*70)
    print("‚úÖ TODOS LOS TESTS PASARON EXITOSAMENTE")
    print("‚úÖ VectorStoreService REAL integrado y funcionando")
    print("‚úÖ Embeddings calculados y almacenados correctamente")
    print("‚úÖ B√∫squeda sem√°ntica operativa")
    print("‚úÖ Stores reales (FAISS/ChromaDB) conectados")
    print("‚úÖ API completamente funcional y robusta")
    print("‚úÖ Sistema listo para RAG en producci√≥n")
    
    print(f"\nüìä RESUMEN T√âCNICO DEL SISTEMA:")
    print(f"üéØ Store activo: {service.get_active_store_type().upper()}")
    print(f"‚úÖ FAISS disponible: {service.faiss_available}")
    print(f"‚úÖ ChromaDB disponible: {service.chromadb_available}")
    print(f"‚úÖ M√©todo is_available(): {service.is_available()}")
    print(f"üß† Embeddings: all-MiniLM-L6-v2 (384 dimensiones)")
    print(f"üíæ Documentos indexados: {len(test_docs)}")
    print(f"üîç B√∫squedas funcionando: ‚úì")
    print(f"üìä M√©tricas disponibles: ‚úì")
    print(f"üè• Health monitoring: ‚úì")
    print(f"üîÑ Switching din√°mico: ‚úì")
    
    print("\nüöÄ ¬°TU SISTEMA RAG EST√Å COMPLETAMENTE OPERATIVO!")
    print("üéì ¬°EL TFM TIENE AHORA UN PROTOTIPO FUNCIONAL AL 100%!")
    
    return True


def show_next_steps():
    """Mostrar los pr√≥ximos pasos para el desarrollo"""
    print("\nüéØ PR√ìXIMOS PASOS RECOMENDADOS")
    print("=" * 50)
    
    print("\n1. üî¨ EJECUTAR BENCHMARKING ACAD√âMICO:")
    print("   python comparison_faiss_vs_chromadb.py")
    print("   ‚Üí Obtendr√°s datos emp√≠ricos para tu TFM")
    
    print("\n2. ü§ñ INTEGRAR LLM SERVICE:")
    print("   ‚Üí Conectar Ollama y OpenAI para generaci√≥n")
    print("   ‚Üí Pipeline RAG completo: Retrieval + Generation")
    
    print("\n3. üåê PROBAR INTERFAZ WEB:")
    print("   python run.py")
    print("   ‚Üí Interface web con stores reales funcionando")
    
    print("\n4. üìä AN√ÅLISIS DE RENDIMIENTO:")
    print("   ‚Üí Ejecutar tests de carga")
    print("   ‚Üí Optimizar par√°metros")
    print("   ‚Üí Documentar m√©tricas")
    
    print("\n5. üìù DOCUMENTAR PARA TFM:")
    print("   ‚Üí Capturas de pantalla del sistema funcionando")
    print("   ‚Üí M√©tricas de rendimiento")
    print("   ‚Üí Comparaciones t√©cnicas")
    
    print("\nüí° EJEMPLOS DE USO EN TU APLICACI√ìN:")
    print("""
# Uso b√°sico del servicio en tu app
from app.services.vector_store_service import get_vector_store_service

service = get_vector_store_service()

# Verificar disponibilidad
if service.is_available():
    # Agregar documentos
    service.add_documents(chunks_con_embeddings)
    
    # Buscar informaci√≥n
    results = service.search("consulta ciudadano", k=5)
    
    # Cambiar de store si es necesario
    service.switch_store("chromadb")  # Para filtros avanzados
    service.switch_store("faiss")     # Para velocidad m√°xima
""")


if __name__ == "__main__":
    print("üéì TFM Vicente Caruncho - Test VectorStoreService Final")
    print("=" * 70)
    
    success = test_vector_store_service_integration()
    
    if success:
        show_next_steps()
        
        print("\nüéâ ¬°FELICIDADES!")
        print("Has logrado implementar un sistema RAG profesional completo.")
        print("Tu TFM est√° en excelente forma para la defensa.")
    else:
        print("\n‚ùå ALGUNOS TESTS FALLARON")
        print("Revisa los errores espec√≠ficos arriba")
        print("El VectorStoreService est√° casi listo, solo faltan detalles menores")
    
    print(f"\nüèÅ Test final completado: {'üéâ SUCCESS' if success else '‚ùå FAILED'}")
    exit(0 if success else 1)